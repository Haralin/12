#!/bin/bash

clear

p=~/bash # путь к целевому каталогу
cd "${p}" # сделать указанный каталог текущим

# прочесть содержимое текущего каталога - файлы и подкаталоги (но не включая . - родительский каталог),
# отсортировать по убыванию размера файла/каталога и отрезать первую часть строк (где размер файла/каталога)
files=$(find -mindepth 1 -maxdepth 1 -printf '%s %f\n' | sort -nr | cut -d' ' -f2-)

IFS=$'\n' # временной определить внутренний разделитель полей как новая строка
# прочесть все строки в массив array
while read -r line; do
    array+=("$line") 
done <<< "$files"
unset IFS # вернуть дефолтное значение

len=${#array[@]}
chunk_size=7 # количество выводимых строк за один раз
start=0 counter=1 # задаем стартовый индекс в массиве и счетчик файлов/подкаталогов
while : # бесконечный цикл while
do
    chunk=("${array[@]:$start:$chunk_size}") # берем первую партию имен - делаем срез массива
    for fname in "${chunk[@]}" ; do # перебираем первую партию имен
        if [[ -d $fname ]]; then # определяем тип
            type="каталог"
            fsize=$(du -hs -b | cut -d\t -f1 | sed -e 's/[\t]//') # получаем размер каталога (с учетом размера самого каталога и содержимого), обрезаем справа путь и удаляем символ табуляции
        else
            type="файл"
            fsize=$(stat -c%s "$fname") # получаем размер файла
        fi
        echo $counter: "$fname [$type, $fsize байт]" # выводим в консоль
        let "counter++" # инкрементируем счетчик
    done
    let "start+=chunk_size" # передвигаем указатель на следующую партию имен
    if [ $start -ge $len ]; then break; fi # если указатель в конце массива, то выходим из цикла - больше выводить нечего
    read -p "Вывести оставшееся содержимое (y/n)?: " resp # спрашиваем
    if [ -z $resp ] || [ $resp != y ]; then break; fi # если ответ пустой (просто нажали Enter) или не y, то выходим из цикла
done


